<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>4&nbsp; Intertemporal Optimization – Notes in Economic Growth and Fluctuations</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Solow.html" rel="next">
<link href="./differenceq.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./ODE.html">Methods</a></li><li class="breadcrumb-item"><a href="./Intertemporal-Optimization.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Intertemporal Optimization</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Notes in Economic Growth and Fluctuations</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Methods</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ODE.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Ordinary Differentials Equations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./differenceq.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Difference Equations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Intertemporal-Optimization.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Intertemporal Optimization</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Benchmark Models in Growth and Fluctuations Theory</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Solow.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">The Solow Model</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Ramsey.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">The Ramsey-Cass-Koopmans Model</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./OLG.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">The Overlapping Generations Model</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Endogenous Growth Theory</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./AK.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">The AK model - Spillovers à la Romer(1986)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./humanK.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Human capital and Growth (Lucas, 1988)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./horizontal-innovations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Horizontal Innovations and Model of Expanding Varieties (Romer, 1990)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./vertical-innovations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Vertical innovations and Model of Quality Ladders (Grossman-Helpman ,1991; Aghion and Howitt 1992)</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">4.1</span> Introduction</a></li>
  <li><a href="#optimal-control-methods" id="toc-optimal-control-methods" class="nav-link" data-scroll-target="#optimal-control-methods"><span class="header-section-number">4.2</span> Optimal Control Methods</a>
  <ul class="collapse">
  <li><a href="#the-optimal-control-method-in-discrete-time" id="toc-the-optimal-control-method-in-discrete-time" class="nav-link" data-scroll-target="#the-optimal-control-method-in-discrete-time"><span class="header-section-number">4.2.1</span> The Optimal Control Method in Discrete Time</a></li>
  <li><a href="#sec-continuousopt" id="toc-sec-continuousopt" class="nav-link" data-scroll-target="#sec-continuousopt"><span class="header-section-number">4.2.2</span> The Optimal Control Method in Continuous Time</a></li>
  </ul></li>
  <li><a href="#dynamic-programming-and-the-bellman-equation" id="toc-dynamic-programming-and-the-bellman-equation" class="nav-link" data-scroll-target="#dynamic-programming-and-the-bellman-equation"><span class="header-section-number">4.3</span> Dynamic Programming and the Bellman Equation</a></li>
  <li><a href="#present-and-current-value-problems" id="toc-present-and-current-value-problems" class="nav-link" data-scroll-target="#present-and-current-value-problems"><span class="header-section-number">4.4</span> Present and Current Value Problems</a></li>
  <li><a href="#transversality-conditions" id="toc-transversality-conditions" class="nav-link" data-scroll-target="#transversality-conditions"><span class="header-section-number">4.5</span> Transversality Conditions</a></li>
  <li><a href="#general-procedures" id="toc-general-procedures" class="nav-link" data-scroll-target="#general-procedures"><span class="header-section-number">4.6</span> General Procedures</a></li>
  <li><a href="#applications" id="toc-applications" class="nav-link" data-scroll-target="#applications"><span class="header-section-number">4.7</span> Applications</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./ODE.html">Methods</a></li><li class="breadcrumb-item"><a href="./Intertemporal-Optimization.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Intertemporal Optimization</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Intertemporal Optimization</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="introduction"><span class="header-section-number">4.1</span> Introduction</h2>
<p>In this chapter, we study techniques applied to dynamic optimizations. Optimization in dynamics economic problems, which are problems in which variables change over time, does not requires new principles vis-à-vis static problems but possesses a specific structure needed to take care about.</p>
<p>The most important part of this specific structure is the relation between <em>stocks</em> and <em>flows</em>. Some variables, which we will denote by <span class="math inline">\(y\)</span>, have the form of stocks, changing gradually over time. Other variables, which we will denote by <span class="math inline">\(x\)</span>, have the form of flows, which can change freely at any instant. Mathematically, stocks are called <em>state variables</em> and flows are called <em>control variables</em>.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>Stock variables evolves according both stocks and flows, control variables control changes in state variables. For instance, savings in period <span class="math inline">\(t\)</span> determine the change in households wealth from period <span class="math inline">\(t\)</span> to period <span class="math inline">\(t+1\)</span>. A general form of the volution of state variables is:</p>
<p><span id="eq-generaldynamics"><span class="math display">\[
y_{t+1}-y_t=Q(y_t,x_t,t )
\tag{4.1}\]</span></span> where <span class="math inline">\(t,t+1,...\)</span> are discrete time periods, <span class="math inline">\(y\)</span> is a state variable (stocks), <span class="math inline">\(x\)</span> is a control variable (flows) and <span class="math inline">\(Q\)</span> is a vector function. There might be additional restrictions that we summarize under the form:</p>
<p><span id="eq-generalrest"><span class="math display">\[
G(y_t,x_t,t)\leq 0
\tag{4.2}\]</span></span></p>
<p>Note that restrictions (<a href="#eq-generaldynamics" class="quarto-xref"><span>4.1</span></a>) and (<a href="#eq-generalrest" class="quarto-xref"><span>4.2</span></a>) have different structure: the former involves directly a dynamic restriction while the latter is a static.</p>
<p>Furthermore, in most dynamic economic problems, agents have to optimize an objective function of the following additively-separable form:</p>
<p><span id="eq-generalobj"><span class="math display">\[
\sum_{t=0}^T F(y_t,x_t,t)
\tag{4.3}\]</span></span></p>
<p>subject to restrictions (<a href="#eq-generaldynamics" class="quarto-xref"><span>4.1</span></a>) and (<a href="#eq-generalrest" class="quarto-xref"><span>4.2</span></a>). Periods start at <span class="math inline">\(t=0\)</span> and end at <span class="math inline">\(T\)</span>, which is potentially infinite. For instance, the function <span class="math inline">\(F(y_t,x_t,t)\)</span> can represent some households’ utility function or firms’ profit at date <span class="math inline">\(t\)</span>.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> Hence, we seek, in such examples, to maximize the sum of stream of instantaneous utilities (or profits) over time. The value of the initial stock at time 0 is taken as given but also at date T+1: such problems have therefore both initial and terminal conditions, the terminal condition being called <em>transversality conditions</em>.</p>
<p>We are going to present two widely used techniques in economics: optimal control and dynamic programming. Both are going to be applied in discrete and continuous time.</p>
</section>
<section id="optimal-control-methods" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="optimal-control-methods"><span class="header-section-number">4.2</span> Optimal Control Methods</h2>
<section id="the-optimal-control-method-in-discrete-time" class="level3" data-number="4.2.1">
<h3 data-number="4.2.1" class="anchored" data-anchor-id="the-optimal-control-method-in-discrete-time"><span class="header-section-number">4.2.1</span> The Optimal Control Method in Discrete Time</h3>
<p>In the optimal control problem, we want to select the variables <span class="math inline">\(y_t\)</span> and <span class="math inline">\(x_t\)</span> for <span class="math inline">\(t=0,1,2...,T\)</span> to find the optimal solution of (<a href="#eq-generalobj" class="quarto-xref"><span>4.3</span></a>) subject to the constraints (<a href="#eq-generaldynamics" class="quarto-xref"><span>4.1</span></a>) and (<a href="#eq-generalrest" class="quarto-xref"><span>4.2</span></a>). To say it differently, we want to find the sequence <span class="math inline">\(x_0,x_1,x_2...x_T\)</span> and <span class="math inline">\(y_1,y_2,...,y_T\)</span> (remember that <span class="math inline">\(y_0\)</span> and <span class="math inline">\(y_{T+1}\)</span> are given) satisfying this problem.</p>
<p>To do so, we define multipliers (or shadow values) and construct the Lagrangian function. Define as <span class="math inline">\(\mu_t\)</span> the multiplier for the constraints (<a href="#eq-generalrest" class="quarto-xref"><span>4.2</span></a>). These have the usual interpretation of shadow values for the constraints in period <span class="math inline">\(t\)</span>. The multipliers for the constraints (<a href="#eq-generaldynamics" class="quarto-xref"><span>4.1</span></a>) are different since they define the first-order change in the objective function if the constraint in the change of the stock is loosened (i.e.&nbsp;if we have a marginal increase in the stock variable <span class="math inline">\(y_{t+1}\)</span>). They are therefore shadow values of the stock variables in period <span class="math inline">\(t+1\)</span> and we denote them <span class="math inline">\(\lambda_{t+1}\)</span>.</p>
<p>We define as <span class="math inline">\(\mathcal{L}\)</span> the Lagrangian function of the full intertemporal problem:</p>
<p><span class="math display">\[
\mathcal{L}= \sum_{t=0}^{T}\{F(y_t,x_t,t)+\lambda_{t+1}\left[y_t+Q(y_t,x_t,t)-y_{t+1}\right]-\mu_tG(y_t,x_t,t) \}
\]</span></p>
<p>Note that because of the time additive structure of the problem, multipliers are also dated at some period.</p>
<p>The first-order conditions for the optimization of the Lagrangian function with respect to the control variables <span class="math inline">\(x\)</span> are:</p>
<p><span class="math display">\[
\frac{\partial \mathcal{L}}{\partial x_t}=0 : \quad F_x(y_t,x_t,t)+\lambda_{t+1}Q_x(y_t,x_t,t)-\mu_tG_x(y_t,x_t,t)=0
\]</span> for <span class="math inline">\(t=0,1,...,T\)</span> and where <span class="math inline">\(F_x\)</span>, <span class="math inline">\(Q_x,\)</span> and <span class="math inline">\(G_x\)</span> are the partial first-order derivatives with respect to <span class="math inline">\(x\)</span>. Note again that we have <span class="math inline">\(T+1\)</span> first-order conditions with respect to <span class="math inline">\(x\)</span> but the only real differences between them is their date.</p>
<p>With respect to <span class="math inline">\(y\)</span>, the first-order conditions are a bit more complex because <span class="math inline">\(y\)</span> appears in two consecutive periods, and therefore two terms of the sum. Let’s rearrange the Lagrangian function to see it clearly.</p>
<p><span class="math display">\[\begin{aligned}
\mathcal{L}= \sum_{t=1}^{T}\{F(y_t,x_t,t)+\lambda_{t+1}Q(y_t,x_t,t)+y_t(\lambda_{t+1}-\lambda_{t})-\mu_tG(y_t,x_t,t) \}\\
+F(y_0,x_0,0)+\lambda_1Q(y_0,x_0,0)+y_0\lambda_1-y_{T+1}\lambda_{T+1}
\end{aligned}\]</span></p>
<p>The final four terms in the previous equation refer to given value of <span class="math inline">\(y\)</span> in period <span class="math inline">\(0\)</span> and <span class="math inline">\(T+1\)</span>. The first order-condition for the optimum of <span class="math inline">\(\mathcal{L}\)</span> for <span class="math inline">\(y_t\)</span>, <span class="math inline">\(t=,1,2...,T\)</span> are:</p>
<p><span id="eq-focstate"><span class="math display">\[\begin{aligned}
\frac{\partial \mathcal{L}}{\partial y_t}=0 : &amp;  \quad F_y(y_t,x_t,t)+\lambda_{t+1}Q_y(y_t,x_t,t)+\lambda_{t+1}-\lambda_t-\mu_tG_y(y_t,x_t,t)=0\\
&amp; \Rightarrow \lambda_{t+1}-\lambda_t=-\left[ F_y(y_t,x_t,t)+\lambda_{t+1}Q_y(y_t,x_t,t)-\mu_tG_y(y_t,x_t,t)\right]
\end{aligned}
\tag{4.4}\]</span></span></p>
<p>These conditions can be written in a more comprehensive and economically useful way. Define a new function, the Hamiltonian function <span class="math inline">\(\mathcal{H}\)</span> as follows:</p>
<p><span id="eq-hamiltonian-discr"><span class="math display">\[
\mathcal{H}(y_t,x_t,\lambda_{t+1},t)= F(y_t,x_t,t)+\lambda_{t+1}Q(y_t,x_t,t)
\tag{4.5}\]</span></span></p>
<p>Equation (<a href="#eq-hamiltonian-discr" class="quarto-xref"><span>4.5</span></a>) suggests that the control variable <span class="math inline">\(x\)</span> must be selected to optimize <span class="math inline">\(\mathcal{H}(y_t,x_t,\lambda_{t+1},t)\)</span> under the constraint <span class="math inline">\(G(y_t,x_t,t)\leq 0\)</span> which can be written into a new Lagrangian:</p>
<p><span class="math display">\[
\tilde{\mathcal{L}}(y_t,x_t,\lambda_{t+1},t)= \mathcal{H}(y_t,x_t,\lambda_{t+1},t)-\mu_tG(y_t,x_t,t)
\]</span></p>
<p>Then equation (<a href="#eq-focstate" class="quarto-xref"><span>4.4</span></a>) can be written more simply as:</p>
<p><span id="eq-focstate2"><span class="math display">\[
\lambda_{t+1}-\lambda_t=-\tilde{\mathcal{L}}_y(y_t,x_t,\lambda_{t+1},t)
\tag{4.6}\]</span></span></p>
<p>Finally, from (<a href="#eq-generaldynamics" class="quarto-xref"><span>4.1</span></a>) and (<a href="#eq-hamiltonian-discr" class="quarto-xref"><span>4.5</span></a>), we get (using the Enveloppe Theorem):</p>
<p><span id="eq-dynamicsol"><span class="math display">\[
y_{t+1}-y_t=\tilde{\mathcal{H}}_{\lambda}(y_t,x_t,\lambda_{t+1},t)=Q(y_t,x_t,t)
\tag{4.7}\]</span></span> These properties of the Hamiltonian function are known as the <strong>Maximum Principle</strong>:</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Maximum Principle</strong>
</div>
</div>
<div class="callout-body-container callout-body">
<p>The necessary first-order conditions for the optimization of (<a href="#eq-generalobj" class="quarto-xref"><span>4.3</span></a>) under the constraints (<a href="#eq-generaldynamics" class="quarto-xref"><span>4.1</span></a>) and (<a href="#eq-generalrest" class="quarto-xref"><span>4.2</span></a>) are the following: (1) for each <span class="math inline">\(t\)</span>, the control variables <span class="math inline">\(x_t\)</span> optimize the Hamiltonian function (<a href="#eq-hamiltonian-discr" class="quarto-xref"><span>4.5</span></a>) under the static constraints (<a href="#eq-generalrest" class="quarto-xref"><span>4.2</span></a>). (2) The changes of <span class="math inline">\(y_t\)</span> and <span class="math inline">\(\lambda_t\)</span> over time are determined by the difference equations (<a href="#eq-focstate2" class="quarto-xref"><span>4.6</span></a>) and (<a href="#eq-dynamicsol" class="quarto-xref"><span>4.7</span></a>).</p>
</div>
</div>
<p>The Maximum Principle, proposed by Pontryagin <em>et al.</em> (1962), facilitates the determination of the first-order conditions for intertemporal optimization problems. It also gives easier interpretations of the first-order conditions of dynamic economic problems we have just seen.</p>
<p>In particular, changes in the decision variables <span class="math inline">\(x_t\)</span> directly impact the objective function (<a href="#eq-generalobj" class="quarto-xref"><span>4.3</span></a>) but also on <span class="math inline">\(y_{t+1}\)</span> through the impact on <span class="math inline">\(Q\)</span>. Hence, the change in the objective function is found by multiplying the impact of <span class="math inline">\(x\)</span> on Q with the shadow value <span class="math inline">\(\lambda_{t+1}\)</span> of <span class="math inline">\(y_{t+1}\)</span>. The Hamiltonian provides a simple way of converting the one-period objective function <span class="math inline">\(F\)</span> to account for the future impact of the current choice of the control variable <span class="math inline">\(x\)</span>. A similar economic interpretation can be obtained to the first-order conditions for the state variable <span class="math inline">\(y\)</span>. A marginal change in <span class="math inline">\(y\)</span> in period <span class="math inline">\(t\)</span> gives the marginal change <span class="math inline">\(F_y-\mu G_y\)</span> in period <span class="math inline">\(t\)</span>, given the shadow value of <span class="math inline">\(\lambda_{t+1}\)</span> The right-hand side of (<a href="#eq-focstate" class="quarto-xref"><span>4.4</span></a>) may be interpreted as a dividend. The change <span class="math inline">\(\lambda_{t+1}-\lambda_t\)</span> is like a capital gain. Equation (<a href="#eq-focstate" class="quarto-xref"><span>4.4</span></a>) tells us that he dividend plus the capital gain should be equal to zero: at the optimim, there can be no excess return from <span class="math inline">\(y\)</span>.</p>
</section>
<section id="sec-continuousopt" class="level3" data-number="4.2.2">
<h3 data-number="4.2.2" class="anchored" data-anchor-id="sec-continuousopt"><span class="header-section-number">4.2.2</span> The Optimal Control Method in Continuous Time</h3>
<p>In many applications, it is more convenient to treat time as a continuous variable. In such case, Equations (<a href="#eq-generaldynamics" class="quarto-xref"><span>4.1</span></a>) and (<a href="#eq-hamiltonian-discr" class="quarto-xref"><span>4.5</span></a>) become:</p>
<p><span id="eq-dynamicont"><span class="math display">\[
\dot{y}(t)=\frac{dy}{dt}=Q(y(t),x(t),t)
\tag{4.8}\]</span></span> <span id="eq-restcont"><span class="math display">\[
G(y(t),x(t),t)\leq 0
\tag{4.9}\]</span></span></p>
<p>For the objective function, Equation (<a href="#eq-generalobj" class="quarto-xref"><span>4.3</span></a>) in continuous time becomes:</p>
<p><span id="eq-contobj"><span class="math display">\[
\int_0^{T}F(y(t),x(t),t)dt
\tag{4.10}\]</span></span></p>
<p>We can use the Hamiltonian function as before:</p>
<p><span id="eq-hamiltoniancont"><span class="math display">\[
\mathcal{H}=F(y(t),x(t),t)+\lambda(t)Q(y(t),x(t),t)
\tag{4.11}\]</span></span></p>
<p>The FOC for the optimization of the Hamiltonian function (<a href="#eq-hamiltoniancont" class="quarto-xref"><span>4.11</span></a>) under the static constraints (<a href="#eq-restcont" class="quarto-xref"><span>4.9</span></a>) are:</p>
<p><span id="eq-foccont"><span class="math display">\[
\frac{\partial \mathcal{H}}{\partial x(t)}-\mu(t)\frac{\partial G}{\partial x(t)}=0 \Rightarrow F_x+\lambda(t)Q_x=\mu(t)G_x
\tag{4.12}\]</span></span></p>
<p><span id="eq-foccont2"><span class="math display">\[
\frac{\partial \mathcal{H}}{\partial y(t)}=-\dot\lambda(t) \Rightarrow  F_y+\lambda(t)Q_y=-\dot{\lambda}(t)
\tag{4.13}\]</span></span></p>
<p><span id="eq-foccont3"><span class="math display">\[
\frac{\partial \mathcal{H}}{\partial \lambda(t)}=\dot{y}(t) \Rightarrow \dot{y}(t)=Q(y(t),x(t),t)
\tag{4.14}\]</span></span></p>
<p>These three equations are the continuous-time equivalent of the discrete time first-order conditions previously obtained.</p>
</section>
</section>
<section id="dynamic-programming-and-the-bellman-equation" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="dynamic-programming-and-the-bellman-equation"><span class="header-section-number">4.3</span> Dynamic Programming and the Bellman Equation</h2>
<p>Dynamic programming is an alternative method of solving the problem at the beginning of this chapter. It is an extremely useful in problems that combine time and uncertainty as ofent happens in economics.</p>
<p>Our problem is the optimization of:</p>
<p><span class="math display">\[
\sum_{t=0}^{T}F(y_t,x_t,t)
\]</span></p>
<p>under the constraints:</p>
<p><span class="math display">\[
y_{t+1}-y_t=Q(y_t,x_t,t)
\]</span></p>
<p>and</p>
<p><span class="math display">\[G(y_t,x_t,t) \leq 0\]</span></p>
<p>for <span class="math inline">\(t=0,1,2,..,T\)</span>. Again, the vectors of initial and final stocks <span class="math inline">\(y_0\)</span> and <span class="math inline">\(y_{T+1}\)</span> are taken as given. We can define the optimal value that comes out of this problem as a function of the initial stocks <span class="math inline">\(y_0\)</span>. Denote this function as <span class="math inline">\(V(y_0)\)</span>. The vector of the first derivatives of this function <span class="math inline">\(V_y(y_0)\)</span> is the vector of the shadow values of these initial stocks.</p>
<p>The additive separability of the objective function and the constraints allow us to make an important generalization of the above ide. Instead of starting off at time zero, let us assume that we start off at time <span class="math inline">\(t=\tau\)</span>. For the decisions thaty start at <span class="math inline">\(\tau\)</span>, the only thing that matters from the past is the vector of stocks <span class="math inline">\(y_{\tau}\)</span>, which is the result of past decisions. Our problem is to optimize an objective function such as (<a href="#eq-generalobj" class="quarto-xref"><span>4.3</span></a>) and the associated constraints, with time starting from <span class="math inline">\(\tau\)</span> and not 0. We define <span class="math inline">\(V(y_{\tau},\tau))\)</span> as the optimal value that emerges as a function of stocks <span class="math inline">\(y_{\tau}\)</span> and period <span class="math inline">\(\tau\)</span>. The vector of the first derivatives <span class="math inline">\(V_y(y_{\tau},\tau)\)</span> denotes the marginal increase in the optimal value for a small increase of stocks in period <span class="math inline">\(\tau\)</span>, which is the vector of shadow values of the initial stocks for the optimization problem that starts in period <span class="math inline">\(\tau\)</span>. This applies at all <span class="math inline">\(t\)</span>.</p>
<p>Let us then select any <span class="math inline">\(t\)</span> and exime the decision of choosing the values of the control variables for thaht period. Any choice of the control viarable <span class="math inline">\(x_t\)</span> will lead to stocks <span class="math inline">\(y_{t+1}\)</span> through ([-#eq-generaldynamics]). What remains is to solve the subproblem for period <span class="math inline">\(t+1\)</span> and to find the optimal value <span class="math inline">\(V(y_{t+1},t+1)\)</span>. The total value in period <span class="math inline">\(t\)</span> of a choice for the control variables <span class="math inline">\(x_t\)</span> starting oof with stocks <span class="math inline">\(y_t\)</span>, can be separated into two terms: <span class="math inline">\(F(y_t,x_t,t)\)</span> which occurs in the current period; and <span class="math inline">\(V(y_{t+1},t+1)\)</span>, which comes about in future periods. The choice of <span class="math inline">\(x_t\)</span> must optimize the sum of these two terms under the relevant constraints. In other words, we have:</p>
<p><span id="eq-bellman"><span class="math display">\[
V(y_t,t)= \max_{x_t}\left[F(y_t,x_t,t)+V(y_t,t+1) \right]
\tag{4.15}\]</span></span></p>
<p>under the constraints (<a href="#eq-generaldynamics" class="quarto-xref"><span>4.1</span></a>) and (<a href="#eq-generalrest" class="quarto-xref"><span>4.2</span></a>) for the specific <span class="math inline">\(t\)</span>.</p>
<p>This method of intertemporal optimization, as a succession of static optimization problems, was proposed by Richard Bellman and is called <em>dynamic programming</em>. The idea that whatever the choice in period <span class="math inline">\(t\)</span>, the choices for the subproblem that begins in period <span class="math inline">\(t+1\)</span> should be optimal, is known as Bellman’s <em>principle of optimality</em>. The optimal value function <span class="math inline">\(V(y_t,t)\)</span> is called the Bellman’s <em>value function</em> and equation (<a href="#eq-bellman" class="quarto-xref"><span>4.16</span></a>) the <em>Bellman equation</em>.</p>
<p>The Bellman equation gives us a recursive method for solving the original optimization problem. The idea is to start from the end and go backward. In period <span class="math inline">\(T\)</span>, there is no future, only the requirement for a given final stock <span class="math inline">\(Y_{T+1}\)</span>. Therefore:</p>
<p><span class="math display">\[
V(y_T,T)=\max_{x_T}F(Y_t,x_T,T)
\]</span></p>
<p>under the constraints:</p>
<p><span class="math display">\[\begin{aligned}
Y_{T+1}=Y_T+Q(y_T,x_T,T) \\
G(y_T,x_T,T) \leq 0
\end{aligned}\]</span></p>
<p>This is a simple probem of static optimization, which gives us the optimal value function <span class="math inline">\(V(Y_T,T)\)</span>. This function can in turn be used in the right-hand side of (<a href="#eq-bellman" class="quarto-xref"><span>4.16</span></a>) for <span class="math inline">\(t=T-1\)</span>. This equation is then another static problem, which gives us the optimal value function <span class="math inline">\(V(y_{T-1},T-1)\)</span>. We can continue iun this way until we reach period <span class="math inline">\(0\)</span>. In pratice, this process provides results for the simplest problems. Analytical solutions exist when the functions <span class="math inline">\(F\)</span>, <span class="math inline">\(G\)</span>, and <span class="math inline">\(Q\)</span> have a very simple form. Where analytical solutions do not exist, we can use numerical solutions, acknowledging that, for many economic applications, we have a better methods than the recursive method to find or characterize the solution.</p>
<p>Note that in the presence of uncertainty, the Bellman equation takes the form:</p>
<p><span id="eq-bellman"><span class="math display">\[
V(y_t,t)= \max_{x_t}\left[F(y_t,x_t,t)+E_tV(y_t,t+1) \right]
\tag{4.16}\]</span></span> where <span class="math inline">\(E\)</span> is the mathematical expectations operator. To find the Bellamn equations in continuous time, note that from (<a href="#eq-bellman" class="quarto-xref"><span>4.16</span></a>) takes the form:</p>
<p><span class="math display">\[
V(y(t),t)= \max_{x(t)}\left[F(y(t),x(t),t)\Delta t+V(y(t+\Delta ty,t+\Delta t) \right]
\]</span></p>
<p>where <span class="math inline">\(\Delta t\)</span> is a small time interval. using a Taylor expansion of the last right-hand side term of the equation above, we get:</p>
<p><span class="math display">\[
V(y(t+\Delta ty,t+\Delta t)=V(y(t),t)+V_y(y(t),t)\left[y(t+\Delta t)-y(t)\right]+V_t(y(t),t)\Delta t
\]</span> and where: <span class="math inline">\(y(t+\Delta t)-y(t)=Q(y(t),x(t),t)\Delta t\)</span> from (<a href="#eq-generaldynamics" class="quarto-xref"><span>4.1</span></a>). Plug this expression and the previous to obtain:</p>
<p><span class="math display">\[
V(y(t),t)= \max_{x(t)}\left[F(y(t),x(t),t)\Delta t+ V(y(t),t)+V_y(y(t),t)Q(y(t),x(t),t)\Delta t+V_t(y(t),t)\Delta t \right]
\]</span></p>
<p>Divide both side by <span class="math inline">\(\Delta t\)</span> and cancelling <span class="math inline">\(V(y(t),t)\)</span> results in:</p>
<p><span class="math display">\[
0= \max_{x(t)}\left[F(y(t),x(t),t)+V_y(y(t),t)Q(y(t),x(t),t)+V_t(y(t),t) \right]
\]</span> Which is a Bellman Equation in continuous time.</p>
</section>
<section id="present-and-current-value-problems" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="present-and-current-value-problems"><span class="header-section-number">4.4</span> Present and Current Value Problems</h2>
<p>Before going through additional details, we need to precise two fundamental points:</p>
<ol type="1">
<li>Dynamic economic problems often discount future values of the objective function</li>
<li>if <span class="math inline">\(T=+\infty\)</span>, there is no guarantee that the objective function (<a href="#eq-generalobj" class="quarto-xref"><span>4.3</span></a>) (or the continuous time version (<a href="#eq-contobj" class="quarto-xref"><span>4.10</span></a> ) is converging. Discounting the objective function is one way to guarantee such convergence.</li>
</ol>
<p>When discounted, the objective functions write:</p>
<p><span id="eq-discountedobj"><span class="math display">\[\begin{aligned}
\sum_{t=0}^T \beta^t F(y_t,x_t,t), \quad \text{in discrete time} \\
\int_{t=0}^T \exp^{-\rho} F(y_t,x_t,t) \quad \text{in continuous time}
\end{aligned} \tag{4.17}\]</span></span></p>
<p>with <span class="math inline">\(\rho&gt;0\)</span> the <strong>rate of time preference</strong> and <span class="math inline">\(\beta=\frac{1}{1+\rho} \in(0,1)\)</span>, the <strong>discount factor</strong>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> This two parameters defines the degree of impatience of the economic agents, or how much they subjectively value the present versus the future. In particular, a low <span class="math inline">\(\beta\)</span> (and a high <span class="math inline">\(\rho\)</span> ) means that the agents is relatively impatient (she puts less weight on future value of the objective function).</p>
<p>From there, there are two different (although equivalent) way to frame the problem. Either build the <strong>present-value Hamiltonian</strong> or the <strong>current-value Hamiltonian</strong>. In continuous time, the present-value Hamiltonian is:<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p><span class="math display">\[
\mathcal{H}=F(y(t),x(t),t)\exp^{-\rho t}+\tilde{\lambda}(t)Q(y(t),x(t),t)
\]</span> The first-order conditions do not merely change in comparison to <a href="#sec-continuousopt" class="quarto-xref"><span>Section 4.2.2</span></a>:</p>
<p><span id="eq-foccontpresent"><span class="math display">\[\begin{aligned}
\frac{\partial \tilde{\mathcal{H}}}{\partial x(t)}=0 &amp;:&amp; \quad F_x\exp^{-\rho t}-\tilde{\lambda}(t)Q_x=0\\
\frac{\partial \tilde{\mathcal{H}}}{\partial y(t)}=-\dot{\tilde{\lambda}} &amp;:&amp; \quad F_y\exp^{-\rho t}-\tilde{\lambda}(t)Q_y=-\dot{\tilde{\lambda}}(t) \\
\frac{\partial \tilde{\mathcal{H}}}{\partial \lambda(t)}=\dot{y}(t)&amp;:&amp; \quad Q(y(t),x(t),t)=\dot{y}(t)
\end{aligned} \tag{4.18}\]</span></span></p>
<p>Using an appropriate change of variable, the current-value Hamiltonian is:</p>
<p><span class="math display">\[
\mathcal{H}=\tilde{\mathcal{H}}\exp^{\rho t}= F(y(t),x(t),t)+\lambda (t)Q(y(t),x(t),t)
\]</span> and where <span class="math inline">\(\lambda(t)=\tilde{\lambda}(t) \exp^{-\rho t}\)</span>. Noting that <span class="math inline">\(-\dot{\tilde{\lambda}}(t)=-(\dot{\lambda}(t)-\rho\lambda (t))\)</span>. The FOC becomes:</p>
<p><span id="eq-foccontcurr"><span class="math display">\[\begin{aligned}
\frac{\partial \mathcal{H}}{\partial x(t)}=0 &amp; : &amp; F_x-\lambda(t)Q_x=0  \\
\frac{\partial \mathcal{H}}{\partial y(t)}=-\dot\lambda(t)-\rho \lambda(t) \equiv -\dot{\tilde{\lambda}}\exp^{-\rho t} &amp;:&amp;  F_y-\lambda(t)Q_y-\rho \lambda(t)=-\dot{\lambda}(t)  \\
\frac{\partial \mathcal{H}}{\partial \lambda(t)}=\dot{y}(t) &amp;:&amp; Q(y(t),x(t),t)=\dot{y}(t)
\end{aligned} \tag{4.19}\]</span></span></p>
<p>Note that using the two first equations in (<a href="#eq-foccontpresent" class="quarto-xref"><span>4.18</span></a>) (in particular by taking the time derivative of the first equation to eliminate the terms in <span class="math inline">\(\tilde{\lambda}\)</span>) leads to the same expression for the second equation of (<a href="#eq-foccontcurr" class="quarto-xref"><span>4.19</span></a>). Hence, starting with the current-value Hamiltonian may save some computations.</p>
<p>A similar approach can be done in the discrete time problem. The present-value Lagrangian writes:</p>
<p><span class="math display">\[
\mathcal{\tilde{L}}=\sum_{t=0}^{T}\beta^{t} F(y_,x_t,t)+\tilde{\lambda}_{t+1}[Q(y_t,x_t,t)+y_t-y_{t+1}]
\]</span> with FOC:</p>
<p><span id="eq-discretepresent"><span class="math display">\[\begin{aligned}
\frac{\partial \mathcal{\tilde{L}}}{\partial x_t}=0 &amp; : &amp; \beta^t F_x+\tilde{\lambda}_{t+1}Q_x=0 \\
\frac{\partial \mathcal{\tilde{L}}}{\partial y_{t}}=0 &amp;: &amp; \beta^t F_y+\tilde{\lambda}_{t+1}Q_y+\tilde{\lambda}_{t+1}-\tilde{\lambda}_t=0 \\
\frac{\partial \mathcal{\tilde{L}}}{\partial \tilde{\lambda}_{t+1}}=0 &amp;: &amp; y_{t+1}-y_t=Q(y_t,x_t,t)
\end{aligned}
\tag{4.20}\]</span></span></p>
<p>Using the change of variable <span class="math inline">\(\tilde{\lambda}=\beta^{t}\lambda_t\)</span>, the current-value Lagrangian is now:</p>
<p><span class="math display">\[
\mathcal{\tilde{L}}=\sum_{t=0}^{T}\beta^{t} F(y_,x_t,t)+\lambda_{t+1}[Q(y_t,x_t,t)+y_t-y_{t+1}]
\]</span> with the following FOCs:</p>
<p><span id="eq-discretecurrent"><span class="math display">\[\begin{aligned}
\frac{\partial \mathcal{\tilde{L}}}{\partial x_t}=0 &amp; : &amp;  F_x+\lambda_{t+1}Q_x=0 \\
\frac{\partial \mathcal{\tilde{L}}}{\partial y_{t}}=0 &amp;: &amp;  F_y+\lambda_{t+1}Q_y+\lambda_{t+1}-\beta^{-1}\lambda_t=0 \\
\frac{\partial \mathcal{\tilde{L}}}{\partial \lambda_{t+1}}=0 &amp;: &amp; y_{t+1}-y_t=Q(y_t,x_t,t)
\end{aligned}
\tag{4.21}\]</span></span></p>
<p>The main differences with the present-value FOCS are that the <span class="math inline">\(\beta^t\)</span> in the first equation eliminates themselves while in the second equation, <span class="math inline">\(\beta^{t+1}\)</span> factorizes the term in <span class="math inline">\(t+1\)</span> and the <span class="math inline">\(\beta^t\)</span> factorizes the term in <span class="math inline">\(t\)</span>, cancelling each other up to one factor <span class="math inline">\(\beta\)</span>. As in the continuous time case, the two formulation are equivalent once solved, although the current-value approach saves additional computations.</p>
<p>Let us look at discounted problem with the dynamic programming approach. Define:</p>
<p><span id="eq-discounteddp"><span class="math display">\[
V(y_t,t)=\sum_{t=0}^{T}\beta^t F(y_t,x_t,t)
\tag{4.22}\]</span></span></p>
<p>subject to:</p>
<p><span class="math display">\[
y_{t+1}-y_t=Q(y_t,x_t,t)
\]</span> Note that the constraint implies <span class="math inline">\(x_t \in H(y_t,y_{t+1},t)\)</span>. Problem (<a href="#eq-discounteddp" class="quarto-xref"><span>4.22</span></a>) writes:<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<p><span id="eq-discounteddp2"><span class="math display">\[\begin{aligned}
V(y_t,t)= \max_{x_t \in H(y_t,y_{t+1})}\sum_{t=0}^{T}\beta^t F(y_t,x_t,t) &amp; =\max_{x_t \in H(y_t,y_{t+1})}\left[F(y_t,x_t,t) + \beta \sum_{t=0}^{T}\beta^t F(y_{t+1},x_{t+1},t+1)\right]\\
&amp; =  \max_{x_t \in H(y_t,y_{t+1})}\left[F(y_t,x_t,t) + \beta V(y_{t+1},t+1)\right]
\end{aligned} \tag{4.23}\]</span></span></p>
<p>To maximize the Bellman equation, write the static lagrangian:</p>
<p><span class="math display">\[
\mathcal{L}=F(y_t,x_t,t) + \beta V(y_{t+1},t+1)+\lambda\left[ Q(y_t,x_t,t)+y_t-y_{t+1}\right]
\]</span></p>
<p>The first-order conditions are:</p>
<p><span class="math display">\[\begin{aligned}
\frac{\partial \mathcal{L}}{\partial x_t}=0 &amp; :&amp; F_x+\lambda Q_x=0\\
\frac{\partial \mathcal{L}}{\partial y_{t+1}}=0 &amp; :&amp; -\lambda +\beta V_{y}=0 \\
\frac{\partial \mathcal{L}}{\partial \lambda}=0 &amp; : &amp; y_{t+1}-y_t=Q(y_t,x_t,t)
\end{aligned}\]</span></p>
<p>Which gives the system to be solved recursively.</p>
<p>The Benveniste-Scheinkman condition gives using (<a href="#eq-discounteddp2" class="quarto-xref"><span>4.23</span></a>):</p>
<p><span class="math display">\[
\frac{\partial V(y_t,t)}{\partial y_t}=F_y+\lambda\left[Q_y+1\right] \Rightarrow  \frac{\partial V(y_{t+1},t+1)}{\partial y_{t+1}}=F_y+\lambda\left[Q_y+1\right]
\]</span> which can be plugged in the FOCs above.</p>
<p>In continuous time, the discounted Bellman Equation is:<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<p><span class="math display">\[
-\dot{V}(y(t),t)+\rho V(y(t),t)=\max_{x(t) \in H(y(t),t)}\left[F(y(t),x(t),t)+v_y(y(t),t)Q(y(t),x(t),t) \right]
\]</span></p>
</section>
<section id="transversality-conditions" class="level2" data-number="4.5">
<h2 data-number="4.5" class="anchored" data-anchor-id="transversality-conditions"><span class="header-section-number">4.5</span> Transversality Conditions</h2>
<p>We have mentioned that initial conditions are usually given a dynamic economic problem, notably because this is part of history. However, we have not deal with terminal conditions, also called <strong>transversality conditions</strong>.</p>
<p>In the case of finite horizon problem where <span class="math inline">\(T&lt;+\infty\)</span>, the terminal condition implies that the stock variables at period <span class="math inline">\(T+1\)</span> are nil. This means that the Lagrangian has additional constraints of the form:</p>
<p><span class="math display">\[
\omega_{T+1}y_{T+1}
\]</span> whose associated FOCs are:<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<p><span class="math display">\[\begin{aligned}
\frac{\mathcal{L}}{\partial y_{T+1}}=0 : -\beta^{T}\lambda_{T+1}+\omega_{t+1}\beta^{T+1}=0
\end{aligned}\]</span> Together with a complementary slackness condition:</p>
<p><span class="math display">\[\begin{aligned}
\frac{\mathcal{L}}{\partial \beta^{T+1}\omega_{T+1}}=y_{t+1}\geq 0 \\
\beta^{T+1}\omega_{T+1}\frac{\mathcal{L}}{\partial \beta^{T+1}\omega_{T+1}}=\beta^{T}\lambda_{T+1}y_{t+1}=0
\end{aligned}\]</span></p>
<p>Since <span class="math inline">\(\lambda_{T+1}\)</span> is not nil (because this would imply an infinite marginal benefits in the objective function), this means that <span class="math inline">\(y_{t+1}=0\)</span>.<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
<p>In continuous time, the equivalent condition at point in time <span class="math inline">\(T\)</span> is:</p>
<p><span class="math display">\[
\lambda(T)y(T)=0
\]</span> But what happens when we are looking at an infinite horizon problem ? The latter saves a lot of complication (basically, everything is equivalent as a two-period problem with “today” and “tomorrow” carried over and over) and is often assumed in dynamic problems. Then, we need to prevent the agents to shift indefinitely its decisions on the stocks <span class="math inline">\(y\)</span> over and over.Hence, the equivalent transversality condition in discrete and continuous time in infinite horizon problems are:</p>
<p><span class="math display">\[\begin{aligned}
\lim_{t\rightarrow +\infty}\lambda_ty_t=0 &amp; \quad \text{in discrete time} \\
\lim_{t\rightarrow +\infty}\lambda(t)y(t)=0 &amp; \quad \text{in continuous time} \\
\end{aligned}\]</span></p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p>This is an abusive interpretation as Kamihigashi (2008) highlights. Transversality conditions and no-Ponzi conditions, which is what we just described, have different roles, in particular transversality conditions are <strong>necessary</strong> in any infinite horizon problem. Be sure to check that there are satisfied (In the next chapters, they are.)</p>
</div>
</div>
</section>
<section id="general-procedures" class="level2" data-number="4.6">
<h2 data-number="4.6" class="anchored" data-anchor-id="general-procedures"><span class="header-section-number">4.6</span> General Procedures</h2>
<p>To summarize and give a “cookbook” approach, we present a general strategy to solve dynamic optimization problem.</p>
<p>For the sequence problem:</p>
<ol type="1">
<li>Write the Lagrangian/Hamiltonian</li>
<li>Find the first-order conditions</li>
<li>Obtain the difference/differentials equations in control and state variables</li>
<li>Use the techniques in <a href="ODE.html" class="quarto-xref"><span>Chapter 2</span></a> or in <a href="differenceq.html" class="quarto-xref"><span>Chapter 3</span></a> to characterize the solution.</li>
</ol>
<p>For the recursive approach, using the Bellman equation, things may differ as you can return to a sequence problem using the Benveniste-Scheinkman (and thus start at the third bullet-point of the previous list after defining the Bellman equation and find the first-order conditions). Otherwise You may also use a “guess and verify approach”, either analytically or numerically, of the value function or the policy function to obtain the solution.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Second-Order Conditions</strong>
</div>
</div>
<div class="callout-body-container callout-body">
<p>Although we do not discuss second-order conditions in this chapter, one needs to check if the Lagrangian/Hamiltonian or the Bellman equation is concave (respectively convex) in order to maximize (respectively minimize) the original problem.</p>
</div>
</div>
</section>
<section id="applications" class="level2" data-number="4.7">
<h2 data-number="4.7" class="anchored" data-anchor-id="applications"><span class="header-section-number">4.7</span> Applications</h2>
<p>To be completed( you can refer to the next part though). One can check Dixit’s manual on optimization.</p>


</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>Not all state variables are stock variable. For instance, past decisions on controls can also be considered as state.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>In such problems, we may see <span class="math inline">\(x_t\)</span> and <span class="math inline">\(y_t\)</span> as respectively the consumption level and the wealth owned at date <span class="math inline">\(t\)</span> in the case of a household, or for the problem of a firm, <span class="math inline">\(x_t\)</span> as the investment decision and <span class="math inline">\(y_t\)</span> as the capital stock installed. <a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>These two parameters are related as follows: <span class="math inline">\(\beta^t=e^{t \ln \beta}=e^{\left(\ln \frac{1}{1+\rho}\right) t}=e^{[\ln 1-\ln (1+\rho)] t}=e^{[0-\ln (1+\rho)] t}=e^{-\rho t}\)</span><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Without loss of generality, we exclude the static constraint <span class="math inline">\(G(y(t),x(t),t)\)</span>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>To obtain the different equalities, just decompose the sum with the terms in period <span class="math inline">\(t\)</span> and the remaining terms and recognizing that: <span class="math inline">\(\sum_{t=1}^{T}\beta^t F(y_{t},x_{t},t)=\sum_{t=0}^{T}\beta^{t+1} F(y_{t+1},x_{t+1},t+1)=\beta \sum_{t=1}^{T}\beta^t F(y_{t},x_{t},t)=\beta V(y_{t+1},t+1)\)</span>.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>The sketch of the proof being more complex here, it is left as an exercise.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>remember that <span class="math inline">\(y_{T+1}\)</span> comes also in the dynamic constraint involving <span class="math inline">\(Q\)</span>.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>For instance, in the example of a household with wealth <span class="math inline">\(y\)</span> and consumption level <span class="math inline">\(x\)</span>, this means that at the final period <span class="math inline">\(T\)</span>, the household consume all its wealth since it has no use for the periods after.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./differenceq.html" class="pagination-link" aria-label="Difference Equations">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Difference Equations</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Solow.html" class="pagination-link" aria-label="The Solow Model">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">The Solow Model</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>